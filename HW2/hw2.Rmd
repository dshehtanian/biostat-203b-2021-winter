---
title: "Biostat 203B Homework 2"
author: "Dominic Shehtanian"
subtitle: Due Feb 5 @ 11:59PM
output:
  html_document: default
  word_document: default
---

Display machine information for reproducibility:
```{r}
sessionInfo()
```

```{r setup}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
library(tidyverse)
library(data.table)
library(lubridate)

os <- sessionInfo()$running
if (str_detect(os, "Linux")) {
  mimic_path <- "/usr/203b-data/mimic-iv"
} else if (str_detect(os, "Windows")) {
  mimic_path <- "C:/Users/dsheh/Desktop/mimic-iv"
}
```

## Q1. PhysioNet credential

At this moment, you should already get credentialed on the PhysioNet. Please include a screenshot of your `Data Use Agreement for the MIMIC-IV (v0.4)`.

**Solution:**

![PhysioNet Credential](./credential.PNG)

Note: In order for the image to appear when this document is knitted, the image file (credential.PNG) must be in same directory as this RMarkdown file.

## Q2. `read.csv` (base R) vs `read_csv` (tidyverse) vs `fread` (data.table)


There are quite a few utilities in R for reading data files. Let us test the speed of reading a moderate sized compressed csv file, `admissions.csv.gz`, by three programs: `read.csv` in base R, `read_csv` in tidyverse, and `fread` in the popular data.table package. Is there any speed difference?

In this homework, we stick to the tidyverse. 

**Solution:**
I stored the admissions data so that is does not create a massive output in the knitted document.
```{r}

system.time(read.csv(str_c(mimic_path, "/core/admissions.csv.gz"), 
  header=TRUE))

```

```{r}

system.time(read_csv(str_c(mimic_path, "/core/admissions.csv.gz")))


```

```{r}

system.time(fread(str_c(mimic_path, "/core/admissions.csv.gz"), 
  header=TRUE))

```

There is a large speed difference between read.csv (8.73s) and read_csv (2.67s). There is a smaller speed difference between read_csv and fread (1.33s). fread is the fastest, followed by read_csv and finally read.csv.

The exact timing will vary based on the environment in which these are ran and resource utilization at the time.
These timing are from running on my Windows laptop.

## Q3. ICU stays

`icustays.csv.gz` (<https://mimic-iv.mit.edu/docs/datasets/icu/icustays/>) contains data about Intensive Care Units (ICU) stays. Summarize following variables using appropriate numerics or graphs:   

- how many unique `stay_id`?  
- how many unique `subject_id`?  
- length of ICU stay  
- first ICU unit  
- last ICU unit  

**Solution:**

```{r}
icu_table<-read_csv(str_c(mimic_path, "/icu/icustays.csv.gz"))
```
Number of unique stay_id:
```{r}
icu_table %>% distinct(stay_id) %>% nrow()
```
Number of unique subject_id:
```{r}
icu_table %>% distinct(subject_id) %>% nrow()
```
Length of ICU stay:
```{r}
icu_table %>% summarise(Avg=mean(los), StDev=sd(los), Min=min(los), Q1=quantile
  (los, 0.25), Median=quantile(los, 0.5), Q3=quantile(los, 0.75), Max=max(los))

ggplot(icu_table,aes(los)) + geom_histogram(fill="steelblue") + 
  labs(x="Length of Stay")

ggplot(icu_table,aes(log(los))) + geom_histogram(fill="steelblue") + 
  labs(x="Natural Log of Length of Stay")

```

First ICU unit
```{r}
icu_table %>% group_by(first_careunit) %>% summarise(N = n())

ggplot(icu_table,aes(first_careunit)) + 
  geom_bar(mapping = aes(fill = first_careunit)) + 
  theme(axis.text.x = element_text(angle = 90)) + labs(x = "First ICU Unit")
```


Last ICU unit
```{r}
icu_table %>% group_by(last_careunit) %>% summarise(N = n())

ggplot(icu_table,aes(last_careunit))+ 
  geom_bar(mapping = aes(fill = last_careunit)) +  
  theme(axis.text.x = element_text(angle = 90)) + labs(x = "Last ICU Unit")
``` 

## Q4. `admission` data

Information of the patients admitted into hospital is available in `ADMISSION.csv.gz`. See <https://mimic-iv.mit.edu/docs/datasets/core/admissions/> for details of each field in this file. Summarize following variables using appropriate graphs. Explain any patterns you observe.   

- admission year  
- admission month  
- admission month day  
- admission week day  
- admission hour (anything unusual?)  
- number of deaths in each year  
- admission type  
- number of admissions per patient  
- admission location  
- discharge location  
- insurance  
- language  
- martial status  
- ethnicity  
- death 

Note it is possible that one patient (uniquely identified by the `SUBJECT_ID`) is admitted into hospital multiple times. When summarizing some demographic information, it makes sense to summarize based on unique patients. 

**Solution:**

```{r}
admit_table <- read_csv(str_c(mimic_path, "/core/admissions.csv.gz"))
```
Admission Year
```{r}
ggplot(admit_table,aes(year(admittime))) + geom_bar(fill = "steelblue") + 
  theme_minimal() + labs(x = "Number of Admissions by Year")
```

It appears that admission start our rising before flattening out by ~2130 and then starting a large decline around ~2190.I did not restrict my analysis to unique patients because I wanted to see all admissions that occurred each year.

Admission Month
```{r}
ggplot(admit_table,aes(month(admittime, label = TRUE, abbr = FALSE))) + 
  geom_bar(fill = "steelblue") + theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Number of Admissions by Month")
```

There are slight differences in number of admissions by month, but overall it looks close to uniformly distributed. Parts of the difference could be due to the different amount of days per month. I did not restrict my analysis to unique patients because I wanted to see all admissions that occurred each month.

Admission Month Day
```{r}
ggplot(admit_table,aes(mday(admittime))) + geom_bar(fill = "steelblue") +
  labs(x = "Number of Admissions by Day of the Month")
```

Most days of the month have approximately equal admissions, but admissions on the 29th, 30th, and 31st are lower. This is probably due to not all months having those days. I did not restrict my analysis to unique patients because I wanted to see all admissions that occurred each day of the month.

Admission Week Day
```{r}
ggplot(admit_table,aes(wday(admittime, label = TRUE, abbr = TRUE))) + 
  geom_bar(fill = "steelblue") + 
  labs(x = "Number of Admissions by Day of the Week")
```

Admissions by day of the week appear to be roughly uniformly distributed. I did not restrict my analysis to unique patients because I wanted to see all admissions that occurred each day of the week.

Deaths in Each Year
```{r}
admit_table %>% drop_na(deathtime) %>% ggplot(aes(year(deathtime))) + geom_bar(
fill = "steelblue") + labs(x = "Number of Deaths per Year") 
```

The number of deaths in each year appears to be distributed similarly to the number of admission in each year, though the number of deaths is much smaller than the number of admissions. Deaths slowly increase until approximately 2140, then remain steady overall, but with some years having large drops until declining significantly around 2190. I did not restrict my analysis to unique patients because I wanted to see the total amount of deaths each year.

Admission Type
```{r}
ggplot(admit_table,aes(admission_type)) + 
  geom_bar(mapping = aes(fill = admission_type)) + 
  theme(axis.text.x = element_text(angle=90)) + labs(x = "Type of Admission")
```

The most admissions appear to occur in EW EMER. EU OBSERVATION and ELECTIVE are the next most common admissions, followed by OBSERVATION ADMIT, URGENT, SURGICAL SAME DAY, DIRECT EMER., DIRECT OBSERVATION, and then AMBULATORY OBSERVATION. I did not choose to analyze this by unique patients, because patients could have multiple different admissions of different types and I wanted to show which admission types were the most common for the hospital.

Number of Admissions per Patient 
```{r}
num_admit <- admit_table %>% group_by(subject_id) %>% summarise(N = n())
num_admit %>% summarise(Min = min(N), Max = max(N), Median = median(N), 
                        Mean = mean(N), N = n())

ggplot(num_admit, aes(N)) + geom_bar(fill = "steelblue") + 
  labs(x = "Number of Visits", y = "Number of Patients")

```

The largest amount of subjects had one admission. As the number of admissions increases, the number of patients who have been admitted that many times appears to decrease exponentially. I conducted this analysis for unique patients because we are analyzing the number of visits by each unique patient.

Admission Location
```{r}
ggplot(admit_table,aes(admission_location)) + 
  geom_bar(mapping = aes(fill = admission_location)) + 
  theme(axis.text.x = element_text(angle = 90)) + labs(x = "Admission Location")
```

Emergency room and physician referral appears to be much more common admission locations than other locations. I did not choose to analyze by unique patient because I wanted to show which locations have the most admissions.

Discharge Location  
```{r}
ggplot(admit_table,aes(discharge_location)) + 
  geom_bar(mapping = aes(fill = discharge_location)) +
  theme(axis.text.x = element_text(angle = 90)) + labs(x = "Discharge Location")
```

Most patients were discharged to home, although there is a large amount of "N/A" observations. I did not choose to analyze by unique patient because I wanted to show the outcomes (discharge location) for each admission.

Insurance
```{r}
distinct(admit_table, subject_id, .keep_all = TRUE) %>% ggplot(aes(insurance)) +
  geom_bar(fill = "steelblue") + labs(x = "Insurance Type")
```

Most patients health insurance is "Other", followed by "Medicare" and then "Medicaid". I chose to analyze distinct patients because I didn't want some types of insurance to be over counted due to some patients visiting many times. 

Language  
``` {r}
distinct(admit_table, subject_id, .keep_all = TRUE) %>% ggplot(aes(language)) +
geom_bar(fill = "steelblue") + labs(x = "Language")
```

The vast majority of patients' language was English. Other languages were catergorized as "?". I chose to analyze distinct patients because I didn't want some languages to be over counted due to some patients visiting many times.


Martial status  
```{r}
distinct(admit_table, subject_id, .keep_all = TRUE) %>% 
ggplot(aes(marital_status)) + geom_bar(fill = "steelblue") +
  labs(x = "Marital Status") 
```

Married and single are the largest groups, but there is a large group with N/A for marital status. Each patient was only counted once so certain marital statuses weren't over counted. 

Ethnicity  
```{r}
distinct(admit_table, subject_id, .keep_all = TRUE) %>% 
ggplot(aes(ethnicity)) + geom_bar(fill="steelblue") + 
theme(axis.text.x=element_text(angle=90))
```

The majority of patients in this data set are white. I chose to analyze distinct patients because I didn't want some ethnic groups to be over counted due to different rates of health care use.

Death (Need to change x axis info)
```{r}
admit_table$deathflag = "No"
admit_table[admit_table$hospital_expire_flag == 1, 16] = "Yes"
admit_table %>% ggplot(aes(deathflag)) + 
  geom_bar(fill = "steelblue") + labs(x = "Number of Deaths") 

```

The vast majority of hospital admissions do not have a death occur. I did not choose to analyze this by distinct patients because it a patient could be admitted multiple times but only can die once and it is more important to understand how many hospital admissions have a death occur, instead of how many unique admitted patients died.

## Q5. `patient` data

Explore `patients.csv.gz` (<https://mimic-iv.mit.edu/docs/datasets/core/patients/>) and summarize following variables using appropriate numerics and graphs:  

- `gender`  
- `anchor_age` (explain pattern you see)
**Solution:**
```{r}
pat_table <- read_csv(str_c(mimic_path, "/core/patients.csv.gz"))
```

Gender
```{r}
pat_table %>% group_by(gender) %>% summarise(N=n())
ggplot(pat_table,aes(gender)) + geom_bar(fill="steelblue") + labs(x="Gender")
```
Anchor Age
```{r}
pat_table %>% summarise(Avg=mean(anchor_age), StDev=sd(anchor_age), Min=
min(anchor_age), Q1=quantile(anchor_age, 0.25), Median=quantile(anchor_age, 0.5)
, Q3=quantile(anchor_age, 0.75), Max=max(anchor_age))

ggplot(pat_table,aes(anchor_age)) + geom_histogram(fill="steelblue") + 
  labs(x="Anchor Age")
```

There is a large amount of patients with an anchor_age of zero, this doesn't make sense, so this probably means those anchor_ages are missing, but we should verify. Otherwise, there appears to be a sinusoidal, but overall decreasing pattern to the data.


## Q6. Lab results

`labevents.csv.gz` (<https://mimic-iv.mit.edu/docs/datasets/hosp/labevents/>) contains all laboratory measurements for patients. 

We are interested in the lab measurements of creatinine (50912), potassium (50971), sodium (50983), chloride (50902), bicarbonate (50882), hematocrit (51221), white blood cell count (51301), glucose (50931), magnesium (50960), calcium (50893), and lactate (50813). Find the `itemid`s of these lab measurements from `d_labitems.csv.gz` and retrieve a subset of `labevents.csv.gz` only containing these items.

**Solution:**
```{r}
dlabitems <- read_csv(str_c(mimic_path, "/hosp/d_labitems.csv.gz"))
```
```{r}
system.time(labevents <- fread(str_c(mimic_path, "/hosp/labevents.csv.gz"), 
                              select = c("subject_id", "hadm_id", "itemid",
                                         "charttime", "valuenum"), nThread = 8))
```
```{r}
labevents_tble <- as_tibble(labevents)
```
```{r}
labevents_tble %>% semi_join(icu_table, by = c("subject_id", "hadm_id")) %>%
  fwrite("labevents_icustays.csv.gz")
```
```{r}
system.time(lab_icu <- read_csv("labevents_icustays.csv.gz"))
```

```{r}
labitems <- c("creatinine", "potassium", "sodium", "chloride", "bicarbonate", 
             "hematocrit", "white blood cell", "glucose", "magnesium", 
             "calcium", "lactate")
itemids <- rep(0, length(labitems))
i <- 1
for (labitem in labitems) {
  print(str_interp("Search for ${labitem}"))
  itemid_list <- dlabitems %>% filter(str_detect(label, 
                                      regex(labitem, ignore_case = TRUE))) %>%
    .$itemid
  itemid <- lab_icu %>% filter(itemid %in% itemid_list) %>% 
    count(itemid) %>% arrange(desc(n)) %>% slice(1) %>% .$itemid
  itemids[i] <- itemid
  i <- i + 1
}
```
```{r}
labitem_list <- tibble(labitem=labitems, itemid=itemids)
labitem_list
```

```{r}
labevent_subset <- filter(lab_icu, itemid %in% itemids)
labevent_subset
```

## Q7. Vitals from chartered events

We are interested in the vitals for ICU patients: heart rate, mean and systolic blood pressure (invasive and noninvasive measurements combined), body temperature, SpO2, and respiratory rate. Find the `itemid`s of these vitals from `d_items.csv.gz` and retrieve a subset of `chartevents.csv.gz` only containing these items.

`chartevents.csv.gz` (<https://mimic-iv.mit.edu/docs/datasets/icu/chartevents/>) contains all the charted data available for a patient. During their ICU stay, the primary repository of a patient’s information is their electronic chart. The `itemid` variable indicates a single measurement type in the database. The `value` variable is the value measured for `itemid`.

`d_items.csv.gz` (<https://mimic-iv.mit.edu/docs/datasets/icu/d_items/>) is the dictionary for the `itemid` in `chartevents.csv.gz`. 

**Solution:**
```{r}
system.time(chart <- fread(str_c(mimic_path, "/icu/chartevents.csv.gz"), 
                           select = c("hadm_id", "itemid", 
                                      "charttime", "valuenum"), nThread = 8))
```
```{r}
system.time(as_tibble(chart) %>% semi_join(icu_table, by = c("hadm_id")) %>%
  fwrite("chart_icustays.csv.gz", nThread = 8))
```
```{r}
system.time(chart_icu <- fread(str_c("chart_icustays.csv.gz"), 
            nThread=8))
```
```{r}
ditems<-read_csv(str_c(mimic_path, "/icu/d_items.csv.gz"))
#chartitems <- c(220045, 220050, 220052, )
```
## Q8. Putting things together

Let us create a tibble for all ICU stays, where rows are  

- first ICU stay of each unique patient  
- adults (age at admission > 18)  

and columns contains at least following variables  

- all variables in `icustays.csv.gz`  
- all variables in `admission.csv.gz`  
- first lab measurements during ICU stay  
- first vitals measurement during ICU stay  
- an indicator variable whether the patient died within 30 days of hospital admission  

```{r}
icu_table %>% group_by(subject_id) %>% slice_min(intime) %>% 
  arrange(subject_id) %>% left_join(admit_table, by = "subject_id", 
                                    "hadm_id") %>% left_join(pat_table, 
                                                             by = "subject_id")
```
```{r}
labevent_subset %>% group_by(subject_id) %>% slice_min(charttime)
```
